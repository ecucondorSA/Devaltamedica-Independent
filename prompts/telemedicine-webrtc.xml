<?xml version="1.0" encoding="UTF-8"?>
<!--
  GPT-5 Optimized Telemedicine & WebRTC Development Prompt
  AltaMedica Platform - Real-time Medical Communications
  Version: 1.0.0
  Last Updated: 2025-08-15
-->

<telemedicine_context>
  <system_architecture>
    <!-- Stack t√©cnico de telemedicina -->
    <components>
      - Signaling Server: Puerto 8888 (WebSocket)
      - WebRTC: Videollamadas P2P con STUN/TURN
      - Quality of Service: Monitoreo latencia/jitter/packet loss
      - Unified Telemedicine Controller en api-server
      - Hooks especializados: useTelemedicineUnified, useWebRTCPatientHybrid
    </components>
    
    <performance_requirements>
      - Latencia m√°xima: 100ms para se√±alizaci√≥n
      - Video bitrate: 1.5-3 Mbps adaptativo
      - Audio priority: Opus codec, 48kHz
      - Reconexi√≥n autom√°tica en <3 segundos
      - Fallback a TURN si P2P falla
    </performance_requirements>
  </system_architecture>

  <reasoning_configuration>
    <!-- Optimizado para operaciones real-time -->
    <reasoning_effort>medium</reasoning_effort>
    <verbosity>low</verbosity>
    <tool_budget>
      - Debugging WebRTC: ilimitado
      - Setup inicial: m√°ximo 10 herramientas
      - Optimizaci√≥n: m√°ximo 5 herramientas
    </tool_budget>
  </reasoning_configuration>

  <context_gathering>
    <priority_files>
      - apps/signaling-server/src/*
      - packages/telemedicine-core/*
      - apps/api-server/src/telemedicine/*
      - apps/doctors/src/hooks/useWebRTC*
      - apps/patients/src/hooks/useTelemedicine*
    </priority_files>
    
    <webrtc_checklist>
      - [ ] Verificar servidor de se√±alizaci√≥n activo
      - [ ] Confirmar configuraci√≥n STUN/TURN
      - [ ] Revisar permisos de c√°mara/micr√≥fono
      - [ ] Validar certificados SSL para producci√≥n
      - [ ] Comprobar firewall/NAT traversal
    </webrtc_checklist>
  </context_gathering>

  <implementation_patterns>
    <connection_flow>
      1. Autenticaci√≥n JWT via UnifiedAuthSystem
      2. Crear/unirse a room en signaling server
      3. Intercambio SDP offer/answer
      4. ICE candidates negotiation
      5. Establecer DataChannel para metadata
      6. Monitor QoS metrics continuamente
      7. Graceful disconnect con cleanup
    </connection_flow>

    <error_handling>
      <network_issues>
        - Auto-retry con backoff exponencial
        - Switchover STUN ‚Üí TURN autom√°tico
        - Preservar estado de sesi√≥n en reconexi√≥n
        - Notificar degradaci√≥n de calidad al usuario
      </network_issues>
      
      <media_issues>
        - Fallback audio-only si video falla
        - Detecci√≥n de dispositivos en tiempo real
        - Permisos: re-prompt con instrucciones claras
        - Echo cancellation y noise suppression
      </media_issues>
    </error_handling>

    <qos_monitoring>
      <!-- Sistema de monitoreo de calidad -->
      <metrics>
        - RTT (Round Trip Time): <150ms bueno, <300ms aceptable
        - Jitter: <30ms bueno, <50ms aceptable
        - Packet Loss: <1% bueno, <3% aceptable
        - Bandwidth: m√≠nimo 1Mbps up/down
        - Video Resolution: adaptativo 480p-1080p
        - Frame Rate: target 30fps, m√≠nimo 15fps
      </metrics>
      
      <alerts>
        - Poor connection: notificaci√≥n visual sutil
        - Critical issues: modal con opciones
        - Auto-ajuste calidad sin intervenci√≥n
        - Logging para an√°lisis posterior
      </alerts>
    </qos_monitoring>
  </implementation_patterns>

  <code_structure>
    <webrtc_hooks>
      ```typescript
      // Patr√≥n est√°ndar para hooks WebRTC
      export function useWebRTCSession() {
        const [connectionState, setConnectionState] = useState<RTCPeerConnectionState>('new');
        const [localStream, setLocalStream] = useState<MediaStream | null>(null);
        const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);
        const [stats, setStats] = useState<RTCStatsReport | null>(null);
        
        // Implementaci√≥n con cleanup apropiado
        useEffect(() => {
          return () => {
            // Cleanup cr√≠tico para evitar memory leaks
            localStream?.getTracks().forEach(track => track.stop());
            peerConnection?.close();
          };
        }, []);
      }
      ```
    </webrtc_hooks>

    <signaling_protocol>
      ```typescript
      // Mensajes de se√±alizaci√≥n est√°ndar
      interface SignalingMessage {
        type: 'offer' | 'answer' | 'ice-candidate' | 'join' | 'leave';
        roomId: string;
        userId: string;
        payload: RTCSessionDescriptionInit | RTCIceCandidateInit;
        metadata?: {
          userName?: string;
          role?: 'doctor' | 'patient';
          sessionType?: 'consultation' | 'emergency';
        };
      }
      ```
    </signaling_protocol>
  </code_structure>

  <tool_preambles>
    <webrtc_setup>
      üé• Configurando sesi√≥n de telemedicina WebRTC...
      Verificando: [‚úì] Se√±alizaci√≥n [‚úì] STUN/TURN [‚úì] Permisos
      Estableciendo conexi√≥n peer-to-peer segura...
    </webrtc_setup>
    
    <debugging_webrtc>
      üîç Diagnosticando problema WebRTC:
      - Estado de conexi√≥n: [STATE]
      - ICE gathering: [ICE_STATE]  
      - Se√±alizaci√≥n: [SIGNALING_STATE]
      Aplicando soluci√≥n...
    </debugging_webrtc>
    
    <optimization_complete>
      ‚ö° Optimizaci√≥n WebRTC completada:
      - Latencia reducida: [BEFORE]ms ‚Üí [AFTER]ms
      - Calidad mejorada: [IMPROVEMENT]
      - Estabilidad: [METRIC]
    </optimization_complete>
  </tool_preambles>

  <testing_requirements>
    <unit_tests>
      - Mock RTCPeerConnection para tests
      - Verificar state machines de conexi√≥n
      - Validar transformaci√≥n de SDP
      - Test reconnection logic
    </unit_tests>
    
    <integration_tests>
      - Flujo completo doctor-patient
      - Simulaci√≥n de p√©rdida de red
      - Cambio de dispositivos mid-call
      - Multi-party calls (si aplica)
    </integration_tests>
    
    <performance_tests>
      - Medir latencia se√±alizaci√≥n
      - Benchmark establecimiento conexi√≥n
      - Stress test con m√∫ltiples peers
      - Memory leak detection
    </performance_tests>
  </testing_requirements>

  <production_checklist>
    - [ ] TURN server configurado y testeado
    - [ ] SSL certificates v√°lidos
    - [ ] Rate limiting en signaling server
    - [ ] Grabaci√≥n de sesiones (si requerido)
    - [ ] Fallback para navegadores legacy
    - [ ] Mobile optimizations aplicadas
    - [ ] Analytics y monitoring activos
  </production_checklist>
</telemedicine_context>