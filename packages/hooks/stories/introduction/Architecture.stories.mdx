import { Meta } from '@storybook/blocks';

<Meta title="Introducci√≥n/Arquitectura" />

# üèóÔ∏è Arquitectura de @altamedica/hooks

## üìÅ Estructura del Package

```
@altamedica/hooks/
‚îú‚îÄ‚îÄ üè• medical/          # Hooks m√©dicos especializados
‚îÇ   ‚îú‚îÄ‚îÄ usePatients      # Gesti√≥n de pacientes
‚îÇ   ‚îú‚îÄ‚îÄ useMedicalAI     # IA m√©dica y diagn√≥sticos
‚îÇ   ‚îú‚îÄ‚îÄ useVitalSigns    # Monitoreo de signos vitales
‚îÇ   ‚îú‚îÄ‚îÄ usePrescriptions # Gesti√≥n de recetas m√©dicas
‚îÇ   ‚îî‚îÄ‚îÄ useAppointments  # Citas y consultas
‚îÇ
‚îú‚îÄ‚îÄ üîê auth/             # Autenticaci√≥n y autorizaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ useAuth          # Autenticaci√≥n principal
‚îÇ   ‚îú‚îÄ‚îÄ usePermissions   # Permisos granulares
‚îÇ   ‚îú‚îÄ‚îÄ useRoles         # Gesti√≥n de roles m√©dicos
‚îÇ   ‚îî‚îÄ‚îÄ useSession       # Gesti√≥n de sesiones
‚îÇ
‚îú‚îÄ‚îÄ ‚ö° realtime/         # Comunicaci√≥n en tiempo real
‚îÇ   ‚îú‚îÄ‚îÄ useWebSocket     # WebSocket m√©dico-optimizado
‚îÇ   ‚îú‚îÄ‚îÄ useNotifications # Alertas m√©dicas
‚îÇ   ‚îú‚îÄ‚îÄ useRealTimeUpdates # Actualizaciones live
‚îÇ   ‚îî‚îÄ‚îÄ useTelemedicine  # WebRTC para videollamadas
‚îÇ
‚îú‚îÄ‚îÄ üöÄ performance/      # Monitoreo y optimizaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ usePerformance   # M√©tricas de performance
‚îÇ   ‚îú‚îÄ‚îÄ useOffline       # Funcionalidad offline
‚îÇ   ‚îú‚îÄ‚îÄ useCache         # Cache inteligente
‚îÇ   ‚îî‚îÄ‚îÄ useMetrics       # Telemetr√≠a m√©dica
‚îÇ
‚îú‚îÄ‚îÄ üõ†Ô∏è utils/           # Utilidades generales
‚îÇ   ‚îú‚îÄ‚îÄ useDebounce      # Debouncing especializado
‚îÇ   ‚îú‚îÄ‚îÄ useLocalStorage  # Storage con encriptaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ useMediaQuery    # Responsive m√©dico
‚îÇ   ‚îî‚îÄ‚îÄ useInterval      # Timers seguros
‚îÇ
‚îú‚îÄ‚îÄ üéØ api/              # Integraci√≥n con APIs
‚îÇ   ‚îú‚îÄ‚îÄ useQuery         # Queries m√©dicas
‚îÇ   ‚îú‚îÄ‚îÄ useMutation      # Mutaciones HIPAA
‚îÇ   ‚îú‚îÄ‚îÄ useInfiniteQuery # Paginaci√≥n m√©dica
‚îÇ   ‚îî‚îÄ‚îÄ useSubscription  # Suscripciones en tiempo real
‚îÇ
‚îú‚îÄ‚îÄ üé® ui/               # Hooks de interfaz
‚îÇ   ‚îú‚îÄ‚îÄ useModal         # Modales m√©dicos
‚îÇ   ‚îú‚îÄ‚îÄ useToast         # Notificaciones UI
‚îÇ   ‚îú‚îÄ‚îÄ useStepper       # Workflows m√©dicos
‚îÇ   ‚îî‚îÄ‚îÄ useDropzone      # Upload de archivos m√©dicos
‚îÇ
‚îú‚îÄ‚îÄ üìù forms/            # Formularios m√©dicos
‚îÇ   ‚îú‚îÄ‚îÄ useForm          # Formularios complejos
‚îÇ   ‚îú‚îÄ‚îÄ useValidation    # Validaci√≥n m√©dica
‚îÇ   ‚îú‚îÄ‚îÄ useFieldArray    # Arrays din√°micos
‚îÇ   ‚îî‚îÄ‚îÄ useFormPersist   # Persistencia de formularios
‚îÇ
‚îî‚îÄ‚îÄ üß© composed/        # Hooks compuestos
    ‚îú‚îÄ‚îÄ useTelemedicineSession # Sesi√≥n completa de telemedicina
    ‚îú‚îÄ‚îÄ useMedicalDashboard    # Dashboard m√©dico integral
    ‚îú‚îÄ‚îÄ usePatientWorkflow     # Workflow de paciente
    ‚îî‚îÄ‚îÄ useEmergencyProtocol   # Protocolos de emergencia
```

## üéØ Principios de Dise√±o

### 1. **Medical-First Architecture**
Cada hook est√° dise√±ado considerando los requisitos m√©dicos espec√≠ficos:

```typescript
// ‚ùå Hook gen√©rico
const { data } = useQuery('/users');

// ‚úÖ Hook m√©dico especializado  
const { patients } = usePatients({
  hipaaCompliant: true,        // Compliance autom√°tico
  auditLog: true,             // Audit trail
  encryptPHI: true,           // Encriptaci√≥n de PHI
  permissions: ['read_medical_records']
});
```

### 2. **Tree-Shaking Optimizado**
Importa solo lo que necesitas para bundles optimizados:

```typescript
// ‚úÖ Import espec√≠fico - Solo ~15KB
import { usePatients } from '@altamedica/hooks/medical';

// ‚úÖ Import por categor√≠a - Solo ~45KB  
import { useAuth, usePermissions } from '@altamedica/auth';

// ‚ùå Import completo - ~200KB (evitar)
import { usePatients } from '@altamedica/hooks';
```

### 3. **Composici√≥n sobre Herencia**
Los hooks complejos se componen de hooks m√°s simples:

```typescript
// useTelemedicineSession compone m√∫ltiples hooks
function useTelemedicineSession(config) {
  const auth = useAuth();
  const webSocket = useWebSocket(config.wsUrl);
  const webRTC = useWebRTC(config.rtcConfig);
  const notifications = useNotifications();
  const performance = usePerformance();
  
  return {
    // API unificada
    startSession,
    endSession,
    sendMessage,
    toggleVideo,
    // Estado combinado
    isConnected: webSocket.connected && webRTC.connected,
    participants: webRTC.participants,
    messages: webSocket.messages
  };
}
```

## üîÑ Flujo de Datos

### Arquitectura Reactiva
```mermaid
graph TD
    A[User Action] --> B[Hook]
    B --> C{Requires Auth?}
    C -->|Yes| D[useAuth]
    C -->|No| E[Process Action]
    D --> F{Has Permission?}
    F -->|Yes| E
    F -->|No| G[Permission Error]
    E --> H{HIPAA Sensitive?}
    H -->|Yes| I[Encrypt Data]
    H -->|No| J[Process Normally]
    I --> K[Audit Log]
    J --> K
    K --> L[Update State]
    L --> M[Notify Components]
```

### Ejemplo de Flujo M√©dico
```typescript
// 1. Usuario busca paciente
const searchPatient = useCallback(async (query) => {
  // 2. Verificar autenticaci√≥n
  if (!user) throw new Error('No autenticado');
  
  // 3. Verificar permisos
  if (!hasPermission('read_medical_records')) {
    throw new Error('Sin permisos');
  }
  
  // 4. Encriptar query si contiene PHI
  const encryptedQuery = hipaaCompliant 
    ? await encrypt(query) 
    : query;
  
  // 5. Realizar b√∫squeda
  const results = await searchAPI(encryptedQuery);
  
  // 6. Audit log
  auditLog({
    action: 'patient_search',
    user: user.id,
    query: anonymize(query),
    resultCount: results.length
  });
  
  // 7. Actualizar estado
  setPatients(results);
}, [user, hasPermission, hipaaCompliant]);
```

## üß† Gesti√≥n de Estado

### Estado Local vs Global

```typescript
// Hook con estado local
function usePatientForm() {
  const [formData, setFormData] = useState({});
  const [errors, setErrors] = useState({});
  // Estado encapsulado en el hook
}

// Hook con estado global (cuando es necesario)
function useAuth() {
  const [user, setUser] = useGlobalState('auth.user');
  const [tokens, setTokens] = useGlobalState('auth.tokens');
  // Estado compartido entre componentes
}
```

### Cache Inteligente
```typescript
function usePatients() {
  const cache = useCache({
    key: 'patients',
    ttl: 5 * 60 * 1000, // 5 minutos
    invalidateOn: ['patient_updated', 'patient_created'],
    encryptInCache: true // Para datos PHI
  });
  
  return {
    patients: cache.data,
    isStale: cache.isStale,
    refetch: cache.invalidate
  };
}
```

## üîå Integraci√≥n con Sistemas Externos

### APIs M√©dicas
```typescript
// Hook espec√≠fico para integraci√≥n FHIR
function useFHIRResource<T>(resourceType: string, id?: string) {
  return useQuery({
    queryKey: ['fhir', resourceType, id],
    queryFn: async () => {
      const response = await fhirClient.read(resourceType, id);
      return validateFHIRResource(response.data);
    },
    enabled: !!id,
    // Cache espec√≠fico para recursos FHIR
    staleTime: 10 * 60 * 1000 // 10 minutos
  });
}
```

### WebRTC para Telemedicina
```typescript
function useWebRTC() {
  const [peerConnection, setPeerConnection] = useState<RTCPeerConnection>();
  
  const initializeConnection = useCallback(async () => {
    const pc = new RTCPeerConnection({
      iceServers: [
        // STUN/TURN servers optimizados para medicina
        { urls: 'stun:medical-stun.altamedica.com' },
        { 
          urls: 'turn:medical-turn.altamedica.com',
          username: 'medical-user',
          credential: await getCredential()
        }
      ]
    });
    
    // Configuraci√≥n espec√≠fica para video m√©dico
    pc.addEventListener('track', handleRemoteTrack);
    pc.addEventListener('icecandidate', handleIceCandidate);
    
    setPeerConnection(pc);
  }, []);
  
  return { peerConnection, initializeConnection };
}
```

## üìä M√©tricas y Monitoring

### Performance Tracking
```typescript
function usePerformanceTracking(hookName: string) {
  const startTime = useRef(performance.now());
  
  useEffect(() => {
    return () => {
      const endTime = performance.now();
      const duration = endTime - startTime.current;
      
      // Track performance espec√≠fico para hooks m√©dicos
      trackMedicalHookPerformance({
        hookName,
        duration,
        component: getCurrentComponent(),
        userId: getCurrentUser()?.id,
        isEmergency: isEmergencyContext()
      });
    };
  }, [hookName]);
}
```

### Error Boundaries M√©dicos
```typescript
function useMedicalErrorBoundary() {
  const handleError = useCallback((error: Error, errorInfo: any) => {
    // Logging especializado para errores m√©dicos
    logMedicalError({
      error: error.message,
      stack: error.stack,
      component: errorInfo.componentStack,
      user: getCurrentUser(),
      patientContext: getCurrentPatient(),
      emergencyLevel: assessEmergencyLevel(error),
      hipaaAffected: containsPHI(error)
    });
    
    // Notificar al equipo m√©dico si es cr√≠tico
    if (isCriticalMedicalError(error)) {
      notifyMedicalTeam({
        type: 'CRITICAL_SYSTEM_ERROR',
        error: sanitizeError(error),
        timestamp: new Date()
      });
    }
  }, []);
  
  return { handleError };
}
```

## üîí Seguridad por Dise√±o

### Encriptaci√≥n Autom√°tica
```typescript
function useSecureStorage<T>(key: string, defaultValue: T) {
  const encrypt = useCallback(async (data: T) => {
    if (containsPHI(data)) {
      return await encryptAES256(JSON.stringify(data), getMedicalKey());
    }
    return JSON.stringify(data);
  }, []);
  
  const decrypt = useCallback(async (encryptedData: string) => {
    try {
      return JSON.parse(await decryptAES256(encryptedData, getMedicalKey()));
    } catch {
      // Fallback para datos no encriptados
      return JSON.parse(encryptedData);
    }
  }, []);
  
  return useAsyncStorage(key, defaultValue, { encrypt, decrypt });
}
```

### Audit Trail Autom√°tico
```typescript
function useAuditedAction<T extends (...args: any[]) => any>(
  action: T,
  actionName: string
): T {
  return useCallback(async (...args: Parameters<T>) => {
    const auditId = generateAuditId();
    
    // Pre-audit
    await auditLog({
      id: auditId,
      action: actionName,
      user: getCurrentUser()?.id,
      timestamp: new Date(),
      parameters: sanitizeParameters(args),
      phase: 'START'
    });
    
    try {
      const result = await action(...args);
      
      // Post-audit success
      await auditLog({
        id: auditId,
        phase: 'SUCCESS',
        result: sanitizeResult(result)
      });
      
      return result;
    } catch (error) {
      // Post-audit error
      await auditLog({
        id: auditId,
        phase: 'ERROR',
        error: sanitizeError(error)
      });
      
      throw error;
    }
  }, [action, actionName]) as T;
}
```

---

Esta arquitectura est√° dise√±ada para crecer con las necesidades m√©dicas mientras mantiene la simplicidad de uso y el m√°ximo rendimiento.
